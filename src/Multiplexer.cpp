static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         Multiplexer.cpp
//
// description :  C++ source for the Multiplexer and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Multiplexer are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.2  2007/09/03 11:01:51  rsune
// Added support for terminated modes
// Added a mutex to the static members
// TODO: Now only one multiplexer (with up to two tango devices) can be used with one server
//
// Revision 1.1.1.1  2007/08/31 14:15:24  rsune
// Minor changes over original Soleil device
//
// Revision 1.1.1.1  2004/11/08 14:14:19  root
// initial import
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name         |  Method's name
//	----------------------------------------
//  State                  |  dev_state()
//  Status                 |  dev_status()
//  SelectByName           |  select_by_name()
//  SelectByChannel        |  select_by_channel()
//  GetSignalsMapping      |  get_signals_mapping()
//  GetSelectionByName     |  get_selection_by_name()
//  GetSelectionByChannel  |  get_selection_by_channel()
//
//===================================================================

#include <NiSwitchSupport.h>
#include <Multiplexer.h>
#include <MultiplexerClass.h>

//----------------------------------------------------------------------------
// DEFINEs
//----------------------------------------------------------------------------
#define k08x1_TOPOLOGY_STR (const char*)"8x1"
#define k16x1_TOPOLOGY_STR (const char*)"16x1"
#define k04x1_terminated_TOPOLOGY_STR (const char*)"4x1 terminated"
#define k08x1_terminated_TOPOLOGY_STR (const char*)"8x1 terminated"

// ============================================================================
// MACROs
// ============================================================================
#define _CCP(X) static_cast<const char*>(X)

namespace Multiplexer_ns
{


//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::Multiplexer(string &s)
// 
// description : 	constructor for simulated Multiplexer
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
Multiplexer::Multiplexer(Tango::DeviceClass *cl,string &s):Tango::Device_3Impl(cl,s.c_str())
{
	init_device();
}

Multiplexer::Multiplexer(Tango::DeviceClass *cl,const char *s):Tango::Device_3Impl(cl,s)
{
	init_device();
}

Multiplexer::Multiplexer(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_3Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Multiplexer::delete_device()
{
	//	Delete device's allocated object
  if (this->mux_)
  {
    delete this->mux_;
    this->mux_ = 0;
  }
}

//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Multiplexer::init_device()
{
	INFO_STREAM << "Multiplexer::Multiplexer() create device " << device_name << endl;

  //- init members
  this->mux_ = 0;

  //- set state to Tango::FAULT
  this->set_state(Tango::FAULT);
  this->set_status("not initialized");

  // Initialise variables to default values
  //--------------------------------------------
  try 
  {
    get_device_property();
  }
  catch (const Tango::DevFailed& df)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [TANGO database error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::Tango::DevFailed exception caught "
                 << "while trying to read device properties from TANGO database"
                 << std::endl;
    //- more verbose
    ERROR_STREAM << df << std::endl;
    //- skip remaining init steps ...
    return;
  }
  catch (...)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [unknown error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::unknown exception caught "
		             << "while trying to read device properties from TANGO database"
                 << std::endl;
    //- skip remaining init steps ...
    return;
  }

  //- abort initialization if properties missing
  if (critical_properties_missing_) {
    ERROR_STREAM << "configuration error - unspecified or invalid device properties" << std::endl;
    this->set_status("configuration error [unspecified or invalid device properties]");
    this->set_state(Tango::FAULT);
    return;
  }

  //- instanciate the Mux: select both topology and mux-id
  Mux::MuxId mux_id = Mux::mux_com0;
  Mux::MuxTopology mux_topology = Mux::mux_topology_dual_8x1;
  std::string tmp = topology;
  std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
  if (tmp == k08x1_TOPOLOGY_STR) {
	  mux_topology = Mux::mux_topology_dual_8x1;
  } else if (tmp == k16x1_TOPOLOGY_STR)
  {
    mux_topology = Mux::mux_topology_single_16x1;
  } else if (tmp == k04x1_terminated_TOPOLOGY_STR)
  {
	  mux_topology = Mux::mux_topology_dual_4x1_terminated;
  } else if (tmp == k08x1_terminated_TOPOLOGY_STR)
  {
	  mux_topology = Mux::mux_topology_single_8x1_terminated;
  } else {
	  ERROR_STREAM << "Device property <Topology> is invalid [should be \"8x1\", \"16x1\", \"4x1 terminated\" or \"8x1 terminated\"]" << std::endl;
	  this->set_status("Device property <Topology> is invalid [should be \"8x1\", \"16x1\", \"4x1 terminated\" or \"8x1 terminated\"]");
	  this->set_state(Tango::FAULT);
	  return;
  }
  

  
  if (muxId == 1)
  {
    mux_id = Mux::mux_com1;
  }

  //- instanciate the Mux
  this->mux_ = new Mux(this);
  if (this->mux_ == 0) 
  {
    ERROR_STREAM << "initialization error [out of memory]" << std::endl;
    this->set_status("nitialization error [out of memory]");
    this->set_state(Tango::FAULT);
    return;
  }

  //- init the Mux 
  try 
  {
    //- actual init
    this->mux_->initialize(niDAQmxDeviceName, mux_topology, mux_id);
    //- attach signal names to mux inputs
    if (signals.size()) {
      this->mux_->set_signals(signals);
    }
  }
  catch (const Tango::DevFailed& df)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [mux initialization error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::Tango::DevFailed exception caught "
                 << "while trying to initialize the multiplexer"
                 << std::endl;
    //- more verbose
    ERROR_STREAM << df << std::endl;
    //- skip remaining init steps ...
    return;
  }
  catch (...)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [unknown error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::unknown exception caught "
		             << "while trying to initialize the multiplexer"
                 << std::endl;
    //- skip remaining init steps ...
    return;
  }

  this->set_state(Tango::RUNNING);
  this->set_status("device up and ready");
}


//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::readDeviceProperies()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Multiplexer::get_device_property()
{
	//	Initialize your default values here.
	//------------------------------------------
  muxId = 0;

	//	Read device properties from database.(Automatic code generation)
	//-------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Signals"));
	dev_prop.push_back(Tango::DbDatum("NiDAQmxDeviceName"));
	dev_prop.push_back(Tango::DbDatum("Topology"));
	dev_prop.push_back(Tango::DbDatum("MuxId"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	MultiplexerClass	*ds_class =
		(static_cast<MultiplexerClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize Signals from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  signals;
	//	Try to initialize Signals from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  signals;
	//	And try to extract Signals value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  signals;

	//	Try to initialize NiDAQmxDeviceName from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  niDAQmxDeviceName;
	//	Try to initialize NiDAQmxDeviceName from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  niDAQmxDeviceName;
	//	And try to extract NiDAQmxDeviceName value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  niDAQmxDeviceName;

	//	Try to initialize Topology from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  topology;
	//	Try to initialize Topology from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  topology;
	//	And try to extract Topology value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  topology;

	//	Try to initialize MuxId from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  muxId;
	//	Try to initialize MuxId from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  muxId;
	//	And try to extract MuxId value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  muxId;



	//	End of Automatic code generation
	//-------------------------------------------------------------

  critical_properties_missing_ = false;

  if (!this->niDAQmxDeviceName.size())
  {
    ERROR_STREAM << "Required device property <NiDAQmxDeviceName> is missing" << std::endl;
    critical_properties_missing_ = true;
  }

  if (!this->topology.size())
  {
    ERROR_STREAM << "Required device property <Topology> is missing" << std::endl;
    critical_properties_missing_ = true;
  }

  if (critical_properties_missing_) {
    return;
  }

  DEBUG_STREAM << "dev-property::NiDAQmxDeviceName::"
               << niDAQmxDeviceName
               << endl;

  if (this->niDAQmxDeviceName.size() || signals.size() == 0)
  {
    for (unsigned long i = 0; i < signals.size(); i++)
    {
      DEBUG_STREAM << "dev-property::Signals::entry::"
                   << i 
                   << "/"
                   << signals.size()
                   << "::"
                   << signals[i]
                   << std::endl;
    }
  }
  else 
  {
    DEBUG_STREAM << "dev-property::Signals::is either empty or missing. "
                 << "No signal names specified"
                 << std::endl;
  }

  DEBUG_STREAM << "dev-property::Topology::"
               << topology 
               << std::endl;

  if (muxId != 0 && muxId != 1)
  {
	  ERROR_STREAM << "Device property <MuxId> is invalid [should be 0 or 1]" << std::endl;
	  critical_properties_missing_ = true;
  }
	  

  DEBUG_STREAM << "dev-property::MuxId::"
               << muxId
               << std::endl;
}

//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Multiplexer::always_executed_hook()
{
	
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::select_by_name
 *
 *	description:	method to execute "SelectByName"
 *	Connect the specified signal to the mux output
 *
 * @param	argin	The name of the signal to select
 *
 */
//+------------------------------------------------------------------
void Multiplexer::select_by_name(Tango::DevString argin)
{
	DEBUG_STREAM << "Multiplexer::select_by_name(): entering... !" << endl;

	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Mux::select_by_name"));
  }

  this->mux_->select(std::string(argin));
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::select_by_channel
 *
 *	description:	method to execute "SelectByChannel"
 *	Connect the specified channel to the mux. output
 *
 * @param	argin	The channel to select. Use a negative value to disconnect.
 *
 */
//+------------------------------------------------------------------
void Multiplexer::select_by_channel(Tango::DevShort argin)
{
	DEBUG_STREAM << "Multiplexer::select_by_channel(): entering... !" << endl;

	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Mux::select_by_channel"));
  }

  if (argin < 0)
    this->mux_->reset();
  else
    this->mux_->select(static_cast<Tango::DevUShort>(argin), true);
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::get_signals_mapping
 *
 *	description:	method to execute "GetSignalsMapping"
 *	The long array contains channel ids while the string array contains signal names
 *
 * @return	The signals mapping
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongStringArray *Multiplexer::get_signals_mapping()
{
	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Mux::get_signals_mapping"));
  }

  return this->mux_->get_signals_list();
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::get_selection_by_name
 *
 *	description:	method to execute "GetSelectionByName"
 *	Returns the currently selected signal
 *
 * @return	The currently selected signal
 *
 */
//+------------------------------------------------------------------
Tango::DevString Multiplexer::get_selection_by_name()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------

	DEBUG_STREAM << "Multiplexer::get_selection_by_name(): entering... !" << endl;

	//	Add your own code to control device here

  const std::string& selection = this->mux_->get_selection_by_name();
  return CORBA::string_dup(selection.c_str());
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::get_selection_by_channel
 *
 *	description:	method to execute "GetSelectionByChannel"
 *	Returns the currently selected channel
 *
 * @return	The currently selected channel
 *
 */
//+------------------------------------------------------------------
Tango::DevShort Multiplexer::get_selection_by_channel()
{
	DEBUG_STREAM << "Multiplexer::get_selection_by_channel(): entering... !" << endl;

	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Multiplexer::get_selection_by_channel"));
  }

	return this->mux_->get_selection_by_channel();
}

}	//	namespace
