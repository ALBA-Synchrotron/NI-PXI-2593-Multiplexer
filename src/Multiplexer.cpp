static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         Multiplexer.cpp
//
// description :  C++ source for the Multiplexer and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Multiplexer are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.1  2007/08/31 14:15:24  rsune
// Initial revision
//
// Revision 1.1.1.1  2004/11/08 14:14:19  root
// initial import
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


//===================================================================
//
//	The folowing table gives the correspondance
//	between commands and method's name.
//
//	Command's name	|	Method's name
//	----------------------------------------
//	State	|	dev_state()
//	Status	|	dev_status()
//	SelectByName	|	select_by_name()
//	SelectByChannel	|	select_by_channel()
//	GetSignalsMapping	|	get_signals_mapping()
//	GetSelectionByName	|	get_selection_by_name()
//	GetSelectionByChannel	|	get_selection_by_channel()
//
//===================================================================

#include <NiSwitchSupport.h>
#include <Multiplexer.h>

//----------------------------------------------------------------------------
// DEFINEs
//----------------------------------------------------------------------------
#define k08x1_TOPOLOGY_STR (const char*)"8x1"
#define k16x1_TOPOLOGY_STR (const char*)"16x1"
#define kMAGIC_CHANNEL     0xFFFF

// ============================================================================
// MACROs
// ============================================================================
#define _CCP(X) static_cast<const char*>(X)

namespace Multiplexer_ns
{


//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::Multiplexer(string &s)
// 
// description : 	constructor for simulated Multiplexer
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
Multiplexer::Multiplexer(Tango::DeviceClass *cl,string &s):Tango::Device_3Impl(cl,s.c_str())
{
	init_device();
}

Multiplexer::Multiplexer(Tango::DeviceClass *cl,const char *s):Tango::Device_3Impl(cl,s)
{
	init_device();
}

Multiplexer::Multiplexer(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_3Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Multiplexer::delete_device()
{
	//	Delete device's allocated object
  if (this->mux_)
  {
    delete this->mux_;
    this->mux_ = 0;
  }
}

//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Multiplexer::init_device()
{
	INFO_STREAM << "Multiplexer::Multiplexer() create device " << device_name << endl;

  //- init members
  this->mux_ = 0;

  //- set state to Tango::FAULT
  this->set_state(Tango::FAULT);
  this->set_status("not initialized");

  // Initialise variables to default values
  //--------------------------------------------
  try 
  {
    get_device_property();
  }
  catch (const Tango::DevFailed& df)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [TANGO database error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::Tango::DevFailed exception caught "
                 << "while trying to read device properties from TANGO database"
                 << std::endl;
    //- more verbose
    ERROR_STREAM << df << std::endl;
    //- skip remaining init steps ...
    return;
  }
  catch (...)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [unknown error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::unknown exception caught "
		             << "while trying to read device properties from TANGO database"
                 << std::endl;
    //- skip remaining init steps ...
    return;
  }

  //- abort initialization if properties missing
  if (critical_properties_missing_) {
    ERROR_STREAM << "configuration error - unspecified or invalid device properties" << std::endl;
    this->set_status("configuration error [unspecified or invalid device properties]");
    this->set_state(Tango::FAULT);
    return;
  }

  //- instanciate the Mux: select both topology and mux-id
  Mux::MuxId mux_id = Mux::mux_com0;
  Mux::MuxTopology mux_topology = Mux::mux_topology_dual_8x1;
  std::string tmp = topology;
  std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
  if (tmp == k16x1_TOPOLOGY_STR)
  {
    mux_topology = Mux::mux_topology_single_16x1;
  }
  if (muxId == 1)
  {
    mux_id = Mux::mux_com1;
  }

  //- instanciate the Mux
  this->mux_ = new Mux(this);
  if (this->mux_ == 0) 
  {
    ERROR_STREAM << "initialization error [out of memory]" << std::endl;
    this->set_status("nitialization error [out of memory]");
    this->set_state(Tango::FAULT);
    return;
  }

  //- init the Mux 
  try 
  {
    //- actual init
    this->mux_->initialize(niDAQmxDeviceName, mux_topology, mux_id);
    //- attach signal names to mux inputs
    if (signals.size()) {
      this->mux_->set_signals(signals);
    }
  }
  catch (const Tango::DevFailed& df)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [mux initialization error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::Tango::DevFailed exception caught "
                 << "while trying to initialize the multiplexer"
                 << std::endl;
    //- more verbose
    ERROR_STREAM << df << std::endl;
    //- skip remaining init steps ...
    return;
  }
  catch (...)
  {
    //- update internal state
    this->set_state(Tango::FAULT);
    this->set_status("initialization error [unknown error]");
    //- verbose
    ERROR_STREAM << "Multiplexer::init_device::unknown exception caught "
		             << "while trying to initialize the multiplexer"
                 << std::endl;
    //- skip remaining init steps ...
    return;
  }

  this->set_state(Tango::RUNNING);
  this->set_status("device up and ready");
}


//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::readDeviceProperies()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Multiplexer::get_device_property()
{
	//	Initialize your default values here.
	//------------------------------------------
  muxId = 0;

	//	Read device properties from database.(Automatic code generation)
	//-------------------------------------------------------------
	Tango::DbData	data;
	data.push_back(Tango::DbDatum("Signals"));
	data.push_back(Tango::DbDatum("NiDAQmxDeviceName"));
	data.push_back(Tango::DbDatum("Topology"));
	data.push_back(Tango::DbDatum("MuxId"));

	//	Call database and extract values
	//--------------------------------------------
	get_db_device()->get_property(data);
	if (data[0].is_empty()==false)	data[0]  >>  signals;
	if (data[1].is_empty()==false)	data[1]  >>  niDAQmxDeviceName;
	if (data[2].is_empty()==false)	data[2]  >>  topology;
	if (data[3].is_empty()==false)	data[3]  >>  muxId;


	//	End of Automatic code generation
	//-------------------------------------------------------------

  critical_properties_missing_ = false;

  if (data[1].is_empty())
  {
    ERROR_STREAM << "Required device property <NiDAQmxDeviceName> is missing" << std::endl;
    critical_properties_missing_ = true;
  }

  if (data[2].is_empty())
  {
    ERROR_STREAM << "Required device property <Topology> is missing" << std::endl;
    critical_properties_missing_ = true;
  }

  if (critical_properties_missing_) {
    return;
  }

  DEBUG_STREAM << "dev-property::NiDAQmxDeviceName::"
               << niDAQmxDeviceName
               << endl;

  if (data[1].is_empty() == false || signals.size() == 0)
  {
    for (unsigned long i = 0; i < signals.size(); i++)
    {
      DEBUG_STREAM << "dev-property::Signals::entry::"
                   << i 
                   << "/"
                   << signals.size()
                   << "::"
                   << signals[i]
                   << std::endl;
    }
  }
  else 
  {
    DEBUG_STREAM << "dev-property::Signals::is either empty or missing. "
                 << "No signal names specified"
                 << std::endl;
  }

  DEBUG_STREAM << "dev-property::Topology::"
               << topology 
               << std::endl;

  //- be sure Topology is valid
  std::string tmp = topology;
  std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
  if (tmp != k08x1_TOPOLOGY_STR && tmp != k16x1_TOPOLOGY_STR)
  {
    ERROR_STREAM << "Device property <Topology> is invalid [should be 8x1 or 16x1]" << std::endl;
    critical_properties_missing_ = true;
  }

  //- be sure MuxId is specified and valid
  if (tmp == k08x1_TOPOLOGY_STR)
  {
    if (data[3].is_empty()) 
    {
      ERROR_STREAM << "Required device property <MuxId> is missing" << endl;
      critical_properties_missing_ = true;
    }
    else if (muxId != 0 && muxId != 1)
    {
      ERROR_STREAM << "Device property <MuxId> is invalid [should be 0 or 1]" << std::endl;
      critical_properties_missing_ = true;
    }
  }

  DEBUG_STREAM << "dev-property::MuxId::"
               << muxId
               << std::endl;
}

//+----------------------------------------------------------------------------
//
// method : 		Multiplexer::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Multiplexer::always_executed_hook()
{
	
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::select_by_name
 *
 *	description:	method to execute "SelectByName"
 *	Connect the specified signal to the mux output
 *
 * @param	argin	The name of the signal to select
 *
 */
//+------------------------------------------------------------------
void Multiplexer::select_by_name(Tango::DevString argin)
{
	DEBUG_STREAM << "Multiplexer::select_by_name(): entering... !" << endl;

	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Mux::select_by_name"));
  }

  this->mux_->select(std::string(argin));
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::select_by_channel
 *
 *	description:	method to execute "SelectByChannel"
 *	Connect the specified channel to the mux. output
 *
 * @param	argin	The channel to select
 *
 */
//+------------------------------------------------------------------
void Multiplexer::select_by_channel(Tango::DevUShort argin)
{
	DEBUG_STREAM << "Multiplexer::select_by_channel(): entering... !" << endl;

	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Mux::select_by_channel"));
  }

  if (argin == static_cast<Tango::DevUShort>(kMAGIC_CHANNEL))
    this->mux_->reset();
  else
    this->mux_->select(argin, true);
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::get_signals_mapping
 *
 *	description:	method to execute "GetSignalsMapping"
 *	The long array contains channel ids while the string array contains signal names
 *
 * @return	The signals mapping
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongStringArray *Multiplexer::get_signals_mapping()
{
	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Mux::get_signals_mapping"));
  }

  return this->mux_->get_signals_list();
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::get_selection_by_name
 *
 *	description:	method to execute "GetSelectionByName"
 *	Returns the currently selected signal
 *
 * @return	The currently selected signal
 *
 */
//+------------------------------------------------------------------
Tango::DevString Multiplexer::get_selection_by_name()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------

	DEBUG_STREAM << "Multiplexer::get_selection_by_name(): entering... !" << endl;

	//	Add your own code to control device here

  const std::string& selection = this->mux_->get_selection_by_name();
  return CORBA::string_dup(selection.c_str());
}

//+------------------------------------------------------------------
/**
 *	method:	Multiplexer::get_selection_by_channel
 *
 *	description:	method to execute "GetSelectionByChannel"
 *	Returns the currently selected channel
 *
 * @return	The currently selected channel
 *
 */
//+------------------------------------------------------------------
Tango::DevShort Multiplexer::get_selection_by_channel()
{
	DEBUG_STREAM << "Multiplexer::get_selection_by_channel(): entering... !" << endl;

	//	Add your own code to control device here

  if (this->mux_ == 0 || this->get_state() == Tango::FAULT)
  {
    Tango::Except::throw_exception(_CCP("CONFIGURATION_ERROR"),
				                           _CCP("multiplexer is not properly initialized"),
				                           _CCP("Multiplexer::get_selection_by_channel"));
  }

	return this->mux_->get_selection_by_channel();
}

}	//	namespace
