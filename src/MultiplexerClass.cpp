static const char *RcsId = "$Header$";

static const char *TagName = "$Name$";

static const char *FileName= "$Source$"; 

static const char *HttpServer= "http://controle/DeviceServer/doc/";

static const char *RCSfile = "$RCSfile$";
//+=============================================================================
//
// file :        MultiplexerClass.cpp
//
// description : C++ source for the MultiplexerClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the Multiplexer once per process.
//
// project :     TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.1  2007/08/31 14:15:24  rsune
// Initial revision
//
// Revision 1.1.1.1  2004/11/08 14:14:19  root
// initial import
//
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


#include <tango.h>

#include <Multiplexer.h>
#include <MultiplexerClass.h>


namespace Multiplexer_ns
{
//+----------------------------------------------------------------------------
//
// method : 		GetSelectionByChannelCmd::GetSelectionByChannelCmd()
// 
// description : 	constructor for the command of the Multiplexer.
//
// In : - name : The command name
//		- in : The input parameter type
//		- out : The output parameter type
//		- in_desc : The input parameter description
//		- out_desc : The output parameter description
//
//-----------------------------------------------------------------------------
GetSelectionByChannelCmd::GetSelectionByChannelCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out,
								const char		*in_desc,
				       			const char		*out_desc,
								Tango::DispLevel level)
:Command(name,in,out,in_desc,out_desc, level)
{
}
//
//	Constructor without in/out parameters description
//
GetSelectionByChannelCmd::GetSelectionByChannelCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out)
:Command(name,in,out)
{
}




//+----------------------------------------------------------------------------
//
// method : 		GetSelectionByChannelCmd::is_allowed()
// 
// description : 	method to test whether command is allowed or not in this
//			state. In this case, the command is allowed only if
//			the device is in ON state
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns :	boolean - true == is allowed , false == not allowed
//
//-----------------------------------------------------------------------------
bool GetSelectionByChannelCmd::is_allowed(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
		//	End of Generated Code

		//	Re-Start of Generated Code
		return true;
}




//+----------------------------------------------------------------------------
//
// method : 		GetSelectionByChannelCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *GetSelectionByChannelCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "DevTemplateCmd::execute(): arrived" << endl;

	return insert((static_cast<Multiplexer *>(device))->get_selection_by_channel());
}

//+----------------------------------------------------------------------------
//
// method : 		GetSelectionByNameCmd::GetSelectionByNameCmd()
// 
// description : 	constructor for the command of the Multiplexer.
//
// In : - name : The command name
//		- in : The input parameter type
//		- out : The output parameter type
//		- in_desc : The input parameter description
//		- out_desc : The output parameter description
//
//-----------------------------------------------------------------------------
GetSelectionByNameCmd::GetSelectionByNameCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out,
								const char		*in_desc,
				       			const char		*out_desc,
								Tango::DispLevel level)
:Command(name,in,out,in_desc,out_desc, level)
{
}
//
//	Constructor without in/out parameters description
//
GetSelectionByNameCmd::GetSelectionByNameCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out)
:Command(name,in,out)
{
}




//+----------------------------------------------------------------------------
//
// method : 		GetSelectionByNameCmd::is_allowed()
// 
// description : 	method to test whether command is allowed or not in this
//			state. In this case, the command is allowed only if
//			the device is in ON state
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns :	boolean - true == is allowed , false == not allowed
//
//-----------------------------------------------------------------------------
bool GetSelectionByNameCmd::is_allowed(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
		//	End of Generated Code

		//	Re-Start of Generated Code
		return true;
}




//+----------------------------------------------------------------------------
//
// method : 		GetSelectionByNameCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *GetSelectionByNameCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "DevTemplateCmd::execute(): arrived" << endl;

	return insert((static_cast<Multiplexer *>(device))->get_selection_by_name());
}

//+----------------------------------------------------------------------------
//
// method : 		GetSignalsMappingCmd::GetSignalsMappingCmd()
// 
// description : 	constructor for the command of the Multiplexer.
//
// In : - name : The command name
//		- in : The input parameter type
//		- out : The output parameter type
//		- in_desc : The input parameter description
//		- out_desc : The output parameter description
//
//-----------------------------------------------------------------------------
GetSignalsMappingCmd::GetSignalsMappingCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out,
								const char		*in_desc,
				       			const char		*out_desc,
								Tango::DispLevel level)
:Command(name,in,out,in_desc,out_desc, level)
{
}
//
//	Constructor without in/out parameters description
//
GetSignalsMappingCmd::GetSignalsMappingCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out)
:Command(name,in,out)
{
}




//+----------------------------------------------------------------------------
//
// method : 		GetSignalsMappingCmd::is_allowed()
// 
// description : 	method to test whether command is allowed or not in this
//			state. In this case, the command is allowed only if
//			the device is in ON state
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns :	boolean - true == is allowed , false == not allowed
//
//-----------------------------------------------------------------------------
bool GetSignalsMappingCmd::is_allowed(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
		//	End of Generated Code

		//	Re-Start of Generated Code
		return true;
}




//+----------------------------------------------------------------------------
//
// method : 		GetSignalsMappingCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *GetSignalsMappingCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "DevTemplateCmd::execute(): arrived" << endl;

	return insert((static_cast<Multiplexer *>(device))->get_signals_mapping());
}

//+----------------------------------------------------------------------------
//
// method : 		SelectByChannelCmd::SelectByChannelCmd()
// 
// description : 	constructor for the command of the Multiplexer.
//
// In : - name : The command name
//		- in : The input parameter type
//		- out : The output parameter type
//		- in_desc : The input parameter description
//		- out_desc : The output parameter description
//
//-----------------------------------------------------------------------------
SelectByChannelCmd::SelectByChannelCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out,
								const char		*in_desc,
				       			const char		*out_desc,
								Tango::DispLevel level)
:Command(name,in,out,in_desc,out_desc, level)
{
}
//
//	Constructor without in/out parameters description
//
SelectByChannelCmd::SelectByChannelCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out)
:Command(name,in,out)
{
}




//+----------------------------------------------------------------------------
//
// method : 		SelectByChannelCmd::is_allowed()
// 
// description : 	method to test whether command is allowed or not in this
//			state. In this case, the command is allowed only if
//			the device is in ON state
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns :	boolean - true == is allowed , false == not allowed
//
//-----------------------------------------------------------------------------
bool SelectByChannelCmd::is_allowed(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
		//	End of Generated Code

		//	Re-Start of Generated Code
		return true;
}




//+----------------------------------------------------------------------------
//
// method : 		SelectByChannelCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *SelectByChannelCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "DevTemplateCmd::execute(): arrived" << endl;

	Tango::DevUShort	argin;
	extract(in_any, argin);

	((static_cast<Multiplexer *>(device))->select_by_channel(argin));
	return new CORBA::Any();
}



//+----------------------------------------------------------------------------
//
// method : 		SelectByNameCmd::SelectByNameCmd()
// 
// description : 	constructor for the command of the Multiplexer.
//
// In : - name : The command name
//		- in : The input parameter type
//		- out : The output parameter type
//		- in_desc : The input parameter description
//		- out_desc : The output parameter description
//
//-----------------------------------------------------------------------------
SelectByNameCmd::SelectByNameCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out,
								const char		*in_desc,
				       			const char		*out_desc,
								Tango::DispLevel level)
:Command(name,in,out,in_desc,out_desc, level)
{
}
//
//	Constructor without in/out parameters description
//
SelectByNameCmd::SelectByNameCmd(	const char		*name,
								Tango::CmdArgType in,
				       			Tango::CmdArgType out)
:Command(name,in,out)
{
}




//+----------------------------------------------------------------------------
//
// method : 		SelectByNameCmd::is_allowed()
// 
// description : 	method to test whether command is allowed or not in this
//			state. In this case, the command is allowed only if
//			the device is in ON state
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns :	boolean - true == is allowed , false == not allowed
//
//-----------------------------------------------------------------------------
bool SelectByNameCmd::is_allowed(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
		//	End of Generated Code

		//	Re-Start of Generated Code
		return true;
}




//+----------------------------------------------------------------------------
//
// method : 		SelectByNameCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *SelectByNameCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "DevTemplateCmd::execute(): arrived" << endl;

	Tango::DevString	argin;
	extract(in_any, argin);

	((static_cast<Multiplexer *>(device))->select_by_name(argin));
	return new CORBA::Any();
}

//
//----------------------------------------------------------------
//	Initialize pointer for singleton pattern
//----------------------------------------------------------------
//
MultiplexerClass *MultiplexerClass::_instance = NULL;

//+----------------------------------------------------------------------------
//
// method : 		MultiplexerClass::MultiplexerClass(string &s)
// 
// description : 	constructor for the MultiplexerClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
MultiplexerClass::MultiplexerClass(string &s):DeviceClass(s)
{

	cout2 << "Entering MultiplexerClass constructor" << endl;
	write_class_property();
	
	cout2 << "Leaving MultiplexerClass constructor" << endl;

}
//+----------------------------------------------------------------------------
//
// method : 		MultiplexerClass::~MultiplexerClass()
// 
// description : 	destructor for the MultiplexerClass
//
//-----------------------------------------------------------------------------
MultiplexerClass::~MultiplexerClass()
{
	_instance = NULL;
}

//+----------------------------------------------------------------------------
//
// method : 		MultiplexerClass::instance
// 
// description : 	Create the object if not already done. Otherwise, just
//			return a pointer to the object
//
// in : - name : The class name
//
//-----------------------------------------------------------------------------
MultiplexerClass *MultiplexerClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new MultiplexerClass(s);
		}
		catch (bad_alloc)
		{
			throw;
		}		
	}		
	return _instance;
}

MultiplexerClass *MultiplexerClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}

//+----------------------------------------------------------------------------
//
// method : 		MultiplexerClass::command_factory
// 
// description : 	Create the command object(s) and store them in the 
//			command list
//
//-----------------------------------------------------------------------------
void MultiplexerClass::command_factory()
{
	command_list.push_back(new SelectByNameCmd("SelectByName",
		Tango::DEV_STRING, Tango::DEV_VOID,
		"The name of the signal to select",
		"N/A",
		Tango::OPERATOR));
	command_list.push_back(new SelectByChannelCmd("SelectByChannel",
		Tango::DEV_USHORT, Tango::DEV_VOID,
		"The channel to select",
		"N/A",
		Tango::OPERATOR));
	command_list.push_back(new GetSignalsMappingCmd("GetSignalsMapping",
		Tango::DEV_VOID, Tango::DEVVAR_LONGSTRINGARRAY,
		"",
		"The signals mapping",
		Tango::OPERATOR));
	command_list.push_back(new GetSelectionByNameCmd("GetSelectionByName",
		Tango::DEV_VOID, Tango::DEV_STRING,
		"",
		"The currently selected signal",
		Tango::OPERATOR));
	command_list.push_back(new GetSelectionByChannelCmd("GetSelectionByChannel",
		Tango::DEV_VOID, Tango::DEV_SHORT,
		"",
		"The currently selected channel",
		Tango::OPERATOR));

	//	add polling if any
	for (unsigned int i=0 ; i<command_list.size(); i++)
	{
	}
}

//+----------------------------------------------------------------------------
//
// method : 		MultiplexerClass::device_factory
// 
// description : 	Create the device object(s) and store them in the 
//			device list
//
// in :		Tango::DevVarStringArray *devlist_ptr : The device name list
//
//-----------------------------------------------------------------------------
void MultiplexerClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	
	for (long i=0 ; i < devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
						
		// Create device and add it into the device list
		//----------------------------------------------------
		device_list.push_back(new Multiplexer(this, (*devlist_ptr)[i]));							 

		// Export device to the outside world
		// Check before id database used.
		//---------------------------------------------
		if (Tango::Util::_UseDb == true)
			export_device(device_list.back());
		else
			export_device(device_list.back(), (*devlist_ptr)[i]);
	}
}
//+----------------------------------------------------------------------------
//
// method : 		MultiplexerClass::write_class_property
// 
// description : 	Set class description as property in database
//
//-----------------------------------------------------------------------------
void MultiplexerClass::write_class_property()
{
	//	First time, check if database used
	//--------------------------------------------
	if (Tango::Util::_UseDb == false)
		return;

	//	Prepeare DbDatum
	//--------------------------------------------
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("NI-Switch Support");
	title << str_title;

	Tango::DbDatum	description("Description");
	string	str_desc("Provides support for the NI-2593 [dual 8x1 or single 16x1 multiplexer]");
	description << str_desc;
	
		// Use the doc_url field to store all information 
		// on the server version and CVS 
		string::size_type pos, len; 
		
		// 1) Manage module name  
		//  get rid of the $RCSfile:  prefix and of Class.cpp suffix 
		string classname = RCSfile;
		
		pos = classname.find("$RCSfile: ");
		len = classname.length();
		
		if (pos != string::npos) 
			classname= classname.substr(pos+10, len- pos-10); 

		pos = classname.find ("Class.cpp",0);
		if (pos != string::npos) 
			classname=classname.substr(0,pos);
		
		// 2)  Manage version number with SOLEIL CVS rules 
		// tag name is in the form : release_1_0 ==> transform it to 1.0
		// 
		string version ; 
		string str_TagName=string(TagName); 
		
		pos = str_TagName.find_first_of("_",0); 
		if (pos != string::npos) 
			version= str_TagName.substr(pos+1, 3);

		pos = version.find_first_of("_",0); 
		if (pos != string::npos) 
			version[pos] = '.';

		
	//  Store all info in the str_url property		
		
		string	str_url=  "Documentation URL = " + string(HttpServer) + classname +"-" + version + "/index.html" + "\n";
		str_url= str_url + " Version CVS Tag = " + string(TagName)+ "\n"; 
		str_url= str_url + " CVS location = " + string(FileName)+ "\n"; 
		
		Tango::DbDatum	doc_url("doc_url");
		
		doc_url << str_url;

		// Push everything in DataBase

		Tango::DbData	data;
		data.push_back(title);
		data.push_back(description);
		data.push_back(doc_url);
		//	Call database and and values
		//--------------------------------------------
		get_db_class()->put_property(data);
}

}	// namespace
